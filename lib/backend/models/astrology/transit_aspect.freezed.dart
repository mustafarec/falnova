// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'transit_aspect.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

TransitAspect _$TransitAspectFromJson(Map<String, dynamic> json) {
  return _TransitAspect.fromJson(json);
}

/// @nodoc
mixin _$TransitAspect {
  String get transitPlanet => throw _privateConstructorUsedError;
  String get sign => throw _privateConstructorUsedError;
  double get degree => throw _privateConstructorUsedError;
  bool get isRetrograde => throw _privateConstructorUsedError;
  String get aspectType => throw _privateConstructorUsedError;
  String get interpretation => throw _privateConstructorUsedError;
  String? get natalPlanet => throw _privateConstructorUsedError;
  double? get orb => throw _privateConstructorUsedError;
  List<NatalAspect> get aspectsToNatal => throw _privateConstructorUsedError;

  /// Serializes this TransitAspect to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of TransitAspect
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TransitAspectCopyWith<TransitAspect> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TransitAspectCopyWith<$Res> {
  factory $TransitAspectCopyWith(
          TransitAspect value, $Res Function(TransitAspect) then) =
      _$TransitAspectCopyWithImpl<$Res, TransitAspect>;
  @useResult
  $Res call(
      {String transitPlanet,
      String sign,
      double degree,
      bool isRetrograde,
      String aspectType,
      String interpretation,
      String? natalPlanet,
      double? orb,
      List<NatalAspect> aspectsToNatal});
}

/// @nodoc
class _$TransitAspectCopyWithImpl<$Res, $Val extends TransitAspect>
    implements $TransitAspectCopyWith<$Res> {
  _$TransitAspectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TransitAspect
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? transitPlanet = null,
    Object? sign = null,
    Object? degree = null,
    Object? isRetrograde = null,
    Object? aspectType = null,
    Object? interpretation = null,
    Object? natalPlanet = freezed,
    Object? orb = freezed,
    Object? aspectsToNatal = null,
  }) {
    return _then(_value.copyWith(
      transitPlanet: null == transitPlanet
          ? _value.transitPlanet
          : transitPlanet // ignore: cast_nullable_to_non_nullable
              as String,
      sign: null == sign
          ? _value.sign
          : sign // ignore: cast_nullable_to_non_nullable
              as String,
      degree: null == degree
          ? _value.degree
          : degree // ignore: cast_nullable_to_non_nullable
              as double,
      isRetrograde: null == isRetrograde
          ? _value.isRetrograde
          : isRetrograde // ignore: cast_nullable_to_non_nullable
              as bool,
      aspectType: null == aspectType
          ? _value.aspectType
          : aspectType // ignore: cast_nullable_to_non_nullable
              as String,
      interpretation: null == interpretation
          ? _value.interpretation
          : interpretation // ignore: cast_nullable_to_non_nullable
              as String,
      natalPlanet: freezed == natalPlanet
          ? _value.natalPlanet
          : natalPlanet // ignore: cast_nullable_to_non_nullable
              as String?,
      orb: freezed == orb
          ? _value.orb
          : orb // ignore: cast_nullable_to_non_nullable
              as double?,
      aspectsToNatal: null == aspectsToNatal
          ? _value.aspectsToNatal
          : aspectsToNatal // ignore: cast_nullable_to_non_nullable
              as List<NatalAspect>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TransitAspectImplCopyWith<$Res>
    implements $TransitAspectCopyWith<$Res> {
  factory _$$TransitAspectImplCopyWith(
          _$TransitAspectImpl value, $Res Function(_$TransitAspectImpl) then) =
      __$$TransitAspectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String transitPlanet,
      String sign,
      double degree,
      bool isRetrograde,
      String aspectType,
      String interpretation,
      String? natalPlanet,
      double? orb,
      List<NatalAspect> aspectsToNatal});
}

/// @nodoc
class __$$TransitAspectImplCopyWithImpl<$Res>
    extends _$TransitAspectCopyWithImpl<$Res, _$TransitAspectImpl>
    implements _$$TransitAspectImplCopyWith<$Res> {
  __$$TransitAspectImplCopyWithImpl(
      _$TransitAspectImpl _value, $Res Function(_$TransitAspectImpl) _then)
      : super(_value, _then);

  /// Create a copy of TransitAspect
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? transitPlanet = null,
    Object? sign = null,
    Object? degree = null,
    Object? isRetrograde = null,
    Object? aspectType = null,
    Object? interpretation = null,
    Object? natalPlanet = freezed,
    Object? orb = freezed,
    Object? aspectsToNatal = null,
  }) {
    return _then(_$TransitAspectImpl(
      transitPlanet: null == transitPlanet
          ? _value.transitPlanet
          : transitPlanet // ignore: cast_nullable_to_non_nullable
              as String,
      sign: null == sign
          ? _value.sign
          : sign // ignore: cast_nullable_to_non_nullable
              as String,
      degree: null == degree
          ? _value.degree
          : degree // ignore: cast_nullable_to_non_nullable
              as double,
      isRetrograde: null == isRetrograde
          ? _value.isRetrograde
          : isRetrograde // ignore: cast_nullable_to_non_nullable
              as bool,
      aspectType: null == aspectType
          ? _value.aspectType
          : aspectType // ignore: cast_nullable_to_non_nullable
              as String,
      interpretation: null == interpretation
          ? _value.interpretation
          : interpretation // ignore: cast_nullable_to_non_nullable
              as String,
      natalPlanet: freezed == natalPlanet
          ? _value.natalPlanet
          : natalPlanet // ignore: cast_nullable_to_non_nullable
              as String?,
      orb: freezed == orb
          ? _value.orb
          : orb // ignore: cast_nullable_to_non_nullable
              as double?,
      aspectsToNatal: null == aspectsToNatal
          ? _value._aspectsToNatal
          : aspectsToNatal // ignore: cast_nullable_to_non_nullable
              as List<NatalAspect>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TransitAspectImpl implements _TransitAspect {
  const _$TransitAspectImpl(
      {required this.transitPlanet,
      required this.sign,
      required this.degree,
      required this.isRetrograde,
      required this.aspectType,
      required this.interpretation,
      this.natalPlanet,
      this.orb,
      final List<NatalAspect> aspectsToNatal = const []})
      : _aspectsToNatal = aspectsToNatal;

  factory _$TransitAspectImpl.fromJson(Map<String, dynamic> json) =>
      _$$TransitAspectImplFromJson(json);

  @override
  final String transitPlanet;
  @override
  final String sign;
  @override
  final double degree;
  @override
  final bool isRetrograde;
  @override
  final String aspectType;
  @override
  final String interpretation;
  @override
  final String? natalPlanet;
  @override
  final double? orb;
  final List<NatalAspect> _aspectsToNatal;
  @override
  @JsonKey()
  List<NatalAspect> get aspectsToNatal {
    if (_aspectsToNatal is EqualUnmodifiableListView) return _aspectsToNatal;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_aspectsToNatal);
  }

  @override
  String toString() {
    return 'TransitAspect(transitPlanet: $transitPlanet, sign: $sign, degree: $degree, isRetrograde: $isRetrograde, aspectType: $aspectType, interpretation: $interpretation, natalPlanet: $natalPlanet, orb: $orb, aspectsToNatal: $aspectsToNatal)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TransitAspectImpl &&
            (identical(other.transitPlanet, transitPlanet) ||
                other.transitPlanet == transitPlanet) &&
            (identical(other.sign, sign) || other.sign == sign) &&
            (identical(other.degree, degree) || other.degree == degree) &&
            (identical(other.isRetrograde, isRetrograde) ||
                other.isRetrograde == isRetrograde) &&
            (identical(other.aspectType, aspectType) ||
                other.aspectType == aspectType) &&
            (identical(other.interpretation, interpretation) ||
                other.interpretation == interpretation) &&
            (identical(other.natalPlanet, natalPlanet) ||
                other.natalPlanet == natalPlanet) &&
            (identical(other.orb, orb) || other.orb == orb) &&
            const DeepCollectionEquality()
                .equals(other._aspectsToNatal, _aspectsToNatal));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      transitPlanet,
      sign,
      degree,
      isRetrograde,
      aspectType,
      interpretation,
      natalPlanet,
      orb,
      const DeepCollectionEquality().hash(_aspectsToNatal));

  /// Create a copy of TransitAspect
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TransitAspectImplCopyWith<_$TransitAspectImpl> get copyWith =>
      __$$TransitAspectImplCopyWithImpl<_$TransitAspectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TransitAspectImplToJson(
      this,
    );
  }
}

abstract class _TransitAspect implements TransitAspect {
  const factory _TransitAspect(
      {required final String transitPlanet,
      required final String sign,
      required final double degree,
      required final bool isRetrograde,
      required final String aspectType,
      required final String interpretation,
      final String? natalPlanet,
      final double? orb,
      final List<NatalAspect> aspectsToNatal}) = _$TransitAspectImpl;

  factory _TransitAspect.fromJson(Map<String, dynamic> json) =
      _$TransitAspectImpl.fromJson;

  @override
  String get transitPlanet;
  @override
  String get sign;
  @override
  double get degree;
  @override
  bool get isRetrograde;
  @override
  String get aspectType;
  @override
  String get interpretation;
  @override
  String? get natalPlanet;
  @override
  double? get orb;
  @override
  List<NatalAspect> get aspectsToNatal;

  /// Create a copy of TransitAspect
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TransitAspectImplCopyWith<_$TransitAspectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

NatalAspect _$NatalAspectFromJson(Map<String, dynamic> json) {
  return _NatalAspect.fromJson(json);
}

/// @nodoc
mixin _$NatalAspect {
  String get natalPlanet => throw _privateConstructorUsedError;
  String get aspectType => throw _privateConstructorUsedError;
  double get orb => throw _privateConstructorUsedError;
  bool get isApplying => throw _privateConstructorUsedError;
  String get interpretation => throw _privateConstructorUsedError;

  /// Serializes this NatalAspect to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NatalAspect
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NatalAspectCopyWith<NatalAspect> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NatalAspectCopyWith<$Res> {
  factory $NatalAspectCopyWith(
          NatalAspect value, $Res Function(NatalAspect) then) =
      _$NatalAspectCopyWithImpl<$Res, NatalAspect>;
  @useResult
  $Res call(
      {String natalPlanet,
      String aspectType,
      double orb,
      bool isApplying,
      String interpretation});
}

/// @nodoc
class _$NatalAspectCopyWithImpl<$Res, $Val extends NatalAspect>
    implements $NatalAspectCopyWith<$Res> {
  _$NatalAspectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NatalAspect
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? natalPlanet = null,
    Object? aspectType = null,
    Object? orb = null,
    Object? isApplying = null,
    Object? interpretation = null,
  }) {
    return _then(_value.copyWith(
      natalPlanet: null == natalPlanet
          ? _value.natalPlanet
          : natalPlanet // ignore: cast_nullable_to_non_nullable
              as String,
      aspectType: null == aspectType
          ? _value.aspectType
          : aspectType // ignore: cast_nullable_to_non_nullable
              as String,
      orb: null == orb
          ? _value.orb
          : orb // ignore: cast_nullable_to_non_nullable
              as double,
      isApplying: null == isApplying
          ? _value.isApplying
          : isApplying // ignore: cast_nullable_to_non_nullable
              as bool,
      interpretation: null == interpretation
          ? _value.interpretation
          : interpretation // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NatalAspectImplCopyWith<$Res>
    implements $NatalAspectCopyWith<$Res> {
  factory _$$NatalAspectImplCopyWith(
          _$NatalAspectImpl value, $Res Function(_$NatalAspectImpl) then) =
      __$$NatalAspectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String natalPlanet,
      String aspectType,
      double orb,
      bool isApplying,
      String interpretation});
}

/// @nodoc
class __$$NatalAspectImplCopyWithImpl<$Res>
    extends _$NatalAspectCopyWithImpl<$Res, _$NatalAspectImpl>
    implements _$$NatalAspectImplCopyWith<$Res> {
  __$$NatalAspectImplCopyWithImpl(
      _$NatalAspectImpl _value, $Res Function(_$NatalAspectImpl) _then)
      : super(_value, _then);

  /// Create a copy of NatalAspect
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? natalPlanet = null,
    Object? aspectType = null,
    Object? orb = null,
    Object? isApplying = null,
    Object? interpretation = null,
  }) {
    return _then(_$NatalAspectImpl(
      natalPlanet: null == natalPlanet
          ? _value.natalPlanet
          : natalPlanet // ignore: cast_nullable_to_non_nullable
              as String,
      aspectType: null == aspectType
          ? _value.aspectType
          : aspectType // ignore: cast_nullable_to_non_nullable
              as String,
      orb: null == orb
          ? _value.orb
          : orb // ignore: cast_nullable_to_non_nullable
              as double,
      isApplying: null == isApplying
          ? _value.isApplying
          : isApplying // ignore: cast_nullable_to_non_nullable
              as bool,
      interpretation: null == interpretation
          ? _value.interpretation
          : interpretation // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NatalAspectImpl implements _NatalAspect {
  const _$NatalAspectImpl(
      {required this.natalPlanet,
      required this.aspectType,
      required this.orb,
      required this.isApplying,
      required this.interpretation});

  factory _$NatalAspectImpl.fromJson(Map<String, dynamic> json) =>
      _$$NatalAspectImplFromJson(json);

  @override
  final String natalPlanet;
  @override
  final String aspectType;
  @override
  final double orb;
  @override
  final bool isApplying;
  @override
  final String interpretation;

  @override
  String toString() {
    return 'NatalAspect(natalPlanet: $natalPlanet, aspectType: $aspectType, orb: $orb, isApplying: $isApplying, interpretation: $interpretation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NatalAspectImpl &&
            (identical(other.natalPlanet, natalPlanet) ||
                other.natalPlanet == natalPlanet) &&
            (identical(other.aspectType, aspectType) ||
                other.aspectType == aspectType) &&
            (identical(other.orb, orb) || other.orb == orb) &&
            (identical(other.isApplying, isApplying) ||
                other.isApplying == isApplying) &&
            (identical(other.interpretation, interpretation) ||
                other.interpretation == interpretation));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, natalPlanet, aspectType, orb, isApplying, interpretation);

  /// Create a copy of NatalAspect
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NatalAspectImplCopyWith<_$NatalAspectImpl> get copyWith =>
      __$$NatalAspectImplCopyWithImpl<_$NatalAspectImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$NatalAspectImplToJson(
      this,
    );
  }
}

abstract class _NatalAspect implements NatalAspect {
  const factory _NatalAspect(
      {required final String natalPlanet,
      required final String aspectType,
      required final double orb,
      required final bool isApplying,
      required final String interpretation}) = _$NatalAspectImpl;

  factory _NatalAspect.fromJson(Map<String, dynamic> json) =
      _$NatalAspectImpl.fromJson;

  @override
  String get natalPlanet;
  @override
  String get aspectType;
  @override
  double get orb;
  @override
  bool get isApplying;
  @override
  String get interpretation;

  /// Create a copy of NatalAspect
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NatalAspectImplCopyWith<_$NatalAspectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
